import{W as v,b as R,E as q}from"./index-CRPwR4u0.js";function m(p){const e=p.split("/").filter(t=>t!=="."),i=[];return e.forEach(t=>{t===".."&&i.length>0&&i[i.length-1]!==".."?i.pop():i.push(t)}),i.join("/")}function x(p,e){p=m(p),e=m(e);const i=p.split("/"),t=e.split("/");return p!==e&&i.every((s,r)=>s===t[r])}class b extends v{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async e=>{var i,t;const s=R(e,e.webFetchExtra),r=await fetch(e.url,s);let o;if(!e.progress)o=await r.blob();else if(!(r!=null&&r.body))o=new Blob;else{const n=r.body.getReader();let a=0;const c=[],d=r.headers.get("content-type"),y=parseInt(r.headers.get("content-length")||"0",10);for(;;){const{done:h,value:u}=await n.read();if(h)break;c.push(u),a+=(u==null?void 0:u.length)||0;const f={url:e.url,bytes:a,contentLength:y};this.notifyListeners("progress",f)}const w=new Uint8Array(a);let l=0;for(const h of c)typeof h>"u"||(w.set(h,l),l+=h.length);o=new Blob([w.buffer],{type:d||void 0})}return{path:(await this.writeFile({path:e.path,directory:(i=e.directory)!==null&&i!==void 0?i:void 0,recursive:(t=e.recursive)!==null&&t!==void 0?t:!1,data:o})).uri,blob:o}}}async initDb(){if(this._db!==void 0)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((e,i)=>{const t=indexedDB.open(this.DB_NAME,this.DB_VERSION);t.onupgradeneeded=b.doUpgrade,t.onsuccess=()=>{this._db=t.result,e(t.result)},t.onerror=()=>i(t.error),t.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(e){const i=e.target.result;switch(e.oldVersion){case 0:case 1:default:i.objectStoreNames.contains("FileStorage")&&i.deleteObjectStore("FileStorage"),i.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}}async dbRequest(e,i){const t=this._writeCmds.indexOf(e)!==-1?"readwrite":"readonly";return this.initDb().then(s=>new Promise((r,o)=>{const n=s.transaction(["FileStorage"],t).objectStore("FileStorage")[e](...i);n.onsuccess=()=>r(n.result),n.onerror=()=>o(n.error)}))}async dbIndexRequest(e,i,t){const s=this._writeCmds.indexOf(i)!==-1?"readwrite":"readonly";return this.initDb().then(r=>new Promise((o,n)=>{const a=r.transaction(["FileStorage"],s).objectStore("FileStorage").index(e)[i](...t);a.onsuccess=()=>o(a.result),a.onerror=()=>n(a.error)}))}getPath(e,i){const t=i!==void 0?i.replace(/^[/]+|[/]+$/g,""):"";let s="";return e!==void 0&&(s+="/"+e),i!==""&&(s+="/"+t),s}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(e){const i=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[i]);if(t===void 0)throw Error("File does not exist.");return{data:t.content?t.content:""}}async writeFile(e){const i=this.getPath(e.directory,e.path);let t=e.data;const s=e.encoding,r=e.recursive,o=await this.dbRequest("get",[i]);if(o&&o.type==="directory")throw Error("The supplied path is a directory.");const n=i.substr(0,i.lastIndexOf("/"));if(await this.dbRequest("get",[n])===void 0){const d=n.indexOf("/",1);if(d!==-1){const y=n.substr(d);await this.mkdir({path:y,directory:e.directory,recursive:r})}}if(!s&&!(t instanceof Blob)&&(t=t.indexOf(",")>=0?t.split(",")[1]:t,!this.isBase64String(t)))throw Error("The supplied data is not valid base64 content.");const a=Date.now(),c={path:i,folder:n,type:"file",size:t instanceof Blob?t.size:t.length,ctime:a,mtime:a,content:t};return await this.dbRequest("put",[c]),{uri:c.path}}async appendFile(e){const i=this.getPath(e.directory,e.path);let t=e.data;const s=e.encoding,r=i.substr(0,i.lastIndexOf("/")),o=Date.now();let n=o;const a=await this.dbRequest("get",[i]);if(a&&a.type==="directory")throw Error("The supplied path is a directory.");if(await this.dbRequest("get",[r])===void 0){const d=r.indexOf("/",1);if(d!==-1){const y=r.substr(d);await this.mkdir({path:y,directory:e.directory,recursive:!0})}}if(!s&&!this.isBase64String(t))throw Error("The supplied data is not valid base64 content.");if(a!==void 0){if(a.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");a.content!==void 0&&!s?t=btoa(atob(a.content)+atob(t)):t=a.content+t,n=a.ctime}const c={path:i,folder:r,type:"file",size:t.length,ctime:n,mtime:o,content:t};await this.dbRequest("put",[c])}async deleteFile(e){const i=this.getPath(e.directory,e.path);if(await this.dbRequest("get",[i])===void 0)throw Error("File does not exist.");if((await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)])).length!==0)throw Error("Folder is not empty.");await this.dbRequest("delete",[i])}async mkdir(e){const i=this.getPath(e.directory,e.path),t=e.recursive,s=i.substr(0,i.lastIndexOf("/")),r=(i.match(/\//g)||[]).length,o=await this.dbRequest("get",[s]),n=await this.dbRequest("get",[i]);if(r===1)throw Error("Cannot create Root directory");if(n!==void 0)throw Error("Current directory does already exist.");if(!t&&r!==2&&o===void 0)throw Error("Parent directory must exist");if(t&&r!==2&&o===void 0){const d=s.substr(s.indexOf("/",1));await this.mkdir({path:d,directory:e.directory,recursive:t})}const a=Date.now(),c={path:i,folder:s,type:"directory",size:0,ctime:a,mtime:a};await this.dbRequest("put",[c])}async rmdir(e){const{path:i,directory:t,recursive:s}=e,r=this.getPath(t,i),o=await this.dbRequest("get",[r]);if(o===void 0)throw Error("Folder does not exist.");if(o.type!=="directory")throw Error("Requested path is not a directory");const n=await this.readdir({path:i,directory:t});if(n.files.length!==0&&!s)throw Error("Folder is not empty");for(const a of n.files){const c=`${i}/${a.name}`;(await this.stat({path:c,directory:t})).type==="file"?await this.deleteFile({path:c,directory:t}):await this.rmdir({path:c,directory:t,recursive:s})}await this.dbRequest("delete",[r])}async readdir(e){const i=this.getPath(e.directory,e.path),t=await this.dbRequest("get",[i]);if(e.path!==""&&t===void 0)throw Error("Folder does not exist.");const s=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)]);return{files:await Promise.all(s.map(async r=>{let o=await this.dbRequest("get",[r]);return o===void 0&&(o=await this.dbRequest("get",[r+"/"])),{name:r.substring(i.length+1),type:o.type,size:o.size,ctime:o.ctime,mtime:o.mtime,uri:o.path}}))}}async getUri(e){const i=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[i]);return t===void 0&&(t=await this.dbRequest("get",[i+"/"])),{uri:(t==null?void 0:t.path)||i}}async stat(e){const i=this.getPath(e.directory,e.path);let t=await this.dbRequest("get",[i]);if(t===void 0&&(t=await this.dbRequest("get",[i+"/"])),t===void 0)throw Error("Entry does not exist.");return{type:t.type,size:t.size,ctime:t.ctime,mtime:t.mtime,uri:t.path}}async rename(e){await this._copy(e,!0)}async copy(e){return this._copy(e,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(e,i=!1){let{toDirectory:t}=e;const{to:s,from:r,directory:o}=e;if(!s||!r)throw Error("Both to and from must be provided");t||(t=o);const n=this.getPath(o,r),a=this.getPath(t,s);if(n===a)return{uri:a};if(x(n,a))throw Error("To path cannot contain the from path");let c;try{c=await this.stat({path:s,directory:t})}catch{const l=s.split("/");l.pop();const h=l.join("/");if(l.length>0&&(await this.stat({path:h,directory:t})).type!=="directory")throw new Error("Parent directory of the to path is a file")}if(c&&c.type==="directory")throw new Error("Cannot overwrite a directory with a file");const d=await this.stat({path:r,directory:o}),y=async(l,h,u)=>{const f=this.getPath(t,l),g=await this.dbRequest("get",[f]);g.ctime=h,g.mtime=u,await this.dbRequest("put",[g])},w=d.ctime?d.ctime:Date.now();switch(d.type){case"file":{const l=await this.readFile({path:r,directory:o});i&&await this.deleteFile({path:r,directory:o});let h;!(l.data instanceof Blob)&&!this.isBase64String(l.data)&&(h=q.UTF8);const u=await this.writeFile({path:s,directory:t,data:l.data,encoding:h});return i&&await y(s,w,d.mtime),u}case"directory":{if(c)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:s,directory:t,recursive:!1}),i&&await y(s,w,d.mtime)}catch{}const l=(await this.readdir({path:r,directory:o})).files;for(const h of l)await this._copy({from:`${r}/${h.name}`,to:`${s}/${h.name}`,directory:o,toDirectory:t},i);i&&await this.rmdir({path:r,directory:o})}}return{uri:a}}isBase64String(e){try{return btoa(atob(e))==e}catch{return!1}}}b._debug=!0;export{b as FilesystemWeb};
